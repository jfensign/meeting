// Generated by CoffeeScript 1.10.0
(function() {
  var Login, User, _, async, config, q, request;

  request = require('superagent');

  config = require('../config');

  User = require('./users');

  async = require('async');

  _ = require('underscore');

  q = require('q');

  Login = (function() {
    var mock_identity_broker, otpGenerate, otpValidate;

    function Login() {}

    mock_identity_broker = {
      userTest1: {
        intranetId: "1",
        avatar: "https://placeholdit.imgix.net/~text?txtsize=10&txt=default&w=80&h=80"
      },
      userTest2: {
        intranetId: "2",
        avatar: "https://placeholdit.imgix.net/~text?txtsize=10&txt=default&w=80&h=80"
      },
      userTest3: {
        intranetId: "3",
        avatar: "https://placeholdit.imgix.net/~text?txtsize=10&txt=default&w=80&h=80"
      }
    };

    otpValidate = function(reqId, otpHint, cb) {
      return request.post(config.auth.endpoint).send({
        requestType: "OTP_VALIDATE",
        requestId: reqId,
        otpInfo: {
          otpValue: otpHint,
          otpHint: otpHint
        }
      }).end(function(e, response) {
        var body, error;
        body = response.body;
        if (body.status === "COMPLETED") {
          return cb(null, body);
        } else {
          error = new Error("Expected COMPLETE response.");
          error.response = response.body;
          return cb(error);
        }
      });
    };

    otpGenerate = function(reqId, otpMethodId, next) {
      return request.post(config.auth.endpoint).send({
        requestType: "OTP_GENERATE",
        requestId: reqId,
        otpInfo: {
          otpMethodId: otpMethodId
        }
      }).end(function(e, response) {
        var error;
        if (response.body.otpHint) {
          return next(null, response.body.otpHint);
        } else {
          error = new Error("Expected otpHint.");
          error.response = response.body;
          return next(error);
        }
      });
    };

    Login.prototype.perform = function(params) {
      var deferred, deviceId, password, resolve_p, username;
      deferred = q.defer();
      username = params.username, password = params.password, deviceId = params.deviceId;
      resolve_p = function(e, result) {
        user_query;
        var user_query;
        if (e) {
          return deferred.reject(e);
        } else {
          user_query = User.findOne({
            name: username
          });
          user_query.select("name");
          return user_query.exec(function(e, user) {
            if (e) {
              deferred.reject(e);
            }
            if (user) {
              return deferred.resolve(_.extend(result, user));
            } else {
              user = new User(_.extend({
                name: username
              }, mock_identity_broker[username]));
              user.save();
              return deferred.resolve(_.extend(result, user));
            }
          });
        }
      };
      async.waterfall([
        function(cb) {
          return request.post(config.auth.endpoint).send({
            requestType: "AUTHENTICATE",
            deviceId: deviceId,
            clientId: config.auth.client_id,
            authInfo: _.pick(params, 'username', 'password', 'clientId')
          }).end(cb);
        }, function(response, cb) {
          var body, error, methodId;
          body = response.body;
          if (body.status === 'ERROR') {
            return cb({
              status: 400,
              message: body.error
            });
          } else if (body.status === 'COMPLETED') {
            return cb(null, body);
          } else if (body.otpHint) {
            return otpValidate(body.requestId, body.otpHint, cb);
          } else if (body.status === 'OTP_DELIVERY_METHOD_SENT') {
            methodId = body.otpDeliveryMethods[0].methodId;
            return otpGenerate(body.requestId, methodId, function(e, otpHint) {
              return otpValidate(body.requestId, otpHint, cb);
            });
          } else {
            error = new Error("Unknown response from token service");
            error.response = body;
            return cb(error);
          }
        }
      ], resolve_p);
      return deferred.promise;
    };

    return Login;

  })();

  module.exports = new Login;

}).call(this);
